<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../vice.texi on 29 September 1998 -->

<TITLE>VICE Manual - 8  Snapshots</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#00000">
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_7.html">previous</A>, <A HREF="vice_9.html">next</A>, <A HREF="vice_15.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC100" HREF="vice_toc.html#TOC100">8  Snapshots</A></H1>

<P>
Every VICE emulator has a built-in snapshot feature, that saves
the complete Emulator state (see below) into one file. This file
can then be used to restore the emulator state by loading it.

</P>



<H2><A NAME="SEC101" HREF="vice_toc.html#TOC101">8.1  Snapshot usage</A></H2>

<P>
A snapshot is one file.  It contains the complete emulator state.  A
snapshot file can be generated by selecting the <CODE>save snapshot</CODE>
menu entry at any time.

</P>
<P>
A snapshot file can be used to restore the emulator state by selecting
the <CODE>load snapshot</CODE> menu entry at any time.

</P>
<P>
<B>Warning</B>: The complete state is saved, but the following things are
<EM>not</EM> restored:

</P>

<P> <UL>
<P> <LI>The ROMs. This can pose problems when restoring the state of a

PET 3032 into a PET 4032 for example. Also attached cartridges are not
saved.  I.e. you have to attach them before restoring a snapshot of run
of such a cartridge.

<P> <LI>The memory configuration.  The VIC20, PET and CBM-II emulators do

have some memory expansion info.  This is saved but not (yet??)
restored.

</UL> </P>



<H2><A NAME="SEC102" HREF="vice_toc.html#TOC102">8.2  Snapshot format</A></H2>

<P>
A snapshot file consists of several modules.
Each module has a name.
A module saves the state of an entity like a CIA, the CPU,
or the memory.

</P>



<H3><A NAME="SEC103" HREF="vice_toc.html#TOC103">8.2.1  Emulator modules</A></H3>

<P>
This section lists the modules that are contained in each of the
emulators snapshot files.

</P>



<H4><A NAME="SEC104" HREF="vice_toc.html#TOC104">8.2.1.1  x64 modules</A></H4>

<P>
The modules in the x64 emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU - although it is a 6510, only the 6502 core is saved here</TD>
</TR>
<TR><TD>C64MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the C64. Also the CPU I/O register contents are saved here.</TD>
</TR>
<TR><TD>VIC-II</TD>

<TD>656*</TD>
<TD>The VIC-II of the C64</TD>
</TR>
<TR><TD>CIA1</TD>

<TD>6526</TD>
<TD>The CIA for the interrupts and the keyboard</TD>
</TR>
<TR><TD>CIA2</TD>

<TD>6526</TD>
<TD>The CIA for the useport, IEC-bus and RS232.</TD>
</TR>
<TR><TD>SID</TD>

<TD>6581</TD>
<TD>The SID sound chip of the C64</TD>
</TR>
<TR><TD>REU*</TD>

<TD></TD>
<TD>The RAM Extension Unit state (optional)</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>An ACIA at $DE00 (optional)</TD>
</TR>
<TR><TD>TPI</TD>

<TD>6525</TD>
<TD>A TPI at $DF00 for a parallel IEEE488 interface (optional)</TD>
</TR></TABLE>

<P>
Some of the modules are optional and are only saved if the specific
feature is enabled at save-time. If the module is found when restoring
the state the optional features are enabled, and disabled otherwise.

</P>


<H4><A NAME="SEC105" HREF="vice_toc.html#TOC105">8.2.1.2  x128 modules</A></H4>



<H4><A NAME="SEC106" HREF="vice_toc.html#TOC106">8.2.1.3  xvic modules</A></H4>



<H4><A NAME="SEC107" HREF="vice_toc.html#TOC107">8.2.1.4  xpet modules</A></H4>



<H4><A NAME="SEC108" HREF="vice_toc.html#TOC108">8.2.1.5  x610 modules</A></H4>

<P>
The modules in the x610 emulator are:

</P>
<TABLE BORDER>

<TR><TD>Name</TD>

<TD>Type</TD>
<TD>Description</TD>
</TR>
<TR><TD>MAINCPU</TD>

<TD>6502</TD>
<TD>The Main CPU - although it is a 6509, only the 6502 core is saved here</TD>
</TR>
<TR><TD>CBM2MEM</TD>

<TD>Memory</TD>
<TD>Holds the RAM contents of the CBM-II models. Also holds the exec-bank and indirection bank registers</TD>
</TR>
<TR><TD>CRTC</TD>

<TD>6545</TD>
<TD>The video chip for the C6*0 and C7*0 models (only those models).</TD>
</TR>
<TR><TD>VIC-II</TD>

<TD>656?</TD>
<TD>The video chip for the C5*0 models (only the C5*0 models).</TD>
</TR>
<TR><TD>CIA1</TD>

<TD>6526</TD>
<TD>The CIA for IEEE 488 and userport.</TD>
</TR>
<TR><TD>TPI1</TD>

<TD>6525</TD>
<TD>TPI 1 for IEEE488</TD>
</TR>
<TR><TD>TPI2</TD>

<TD>6525</TD>
<TD>TPI 2 for interrupts and keyboard.</TD>
</TR>
<TR><TD>ACIA1</TD>

<TD>6551</TD>
<TD>The RS232 interface</TD>
</TR>
<TR><TD>SID</TD>

<TD>6581</TD>
<TD>The CBM2s SID sound chip</TD>
</TR></TABLE>

<P>
The snapshot either contains CRTC or VIC-II snapshot modules, but
not both. Depending on which module is found, a C5*0 or C6*0 is
emulated.

</P>


<H3><A NAME="SEC109" HREF="vice_toc.html#TOC109">8.2.2  Module formats</A></H3>

<P>
This section shows the basic module framework and
the contents of the different types of modules.

</P>
<P>
The single chip modules contain the <B>chip</B> state, not the
state of the emulator. We tried to make the format as implementation-independent
as possible, to allow reuse of snapshots in later versions of this
emulator, or even in other emulators.

</P>



<H4><A NAME="SEC110" HREF="vice_toc.html#TOC110">8.2.2.1  Terminology</A></H4>

<P>
In this section we use certain abbreviations to define the types of the
data saved in the snapshot.

</P>
<DL COMPACT>

<P><DT><CODE>BYTE</CODE>
<DD>
8 bit integer.
<P><DT><CODE>WORD</CODE>
<DD>
16 bit integer. Saved with low-byte first, high-byte last.
<P><DT><CODE>DWORD</CODE>
<DD>
32 bit integer. Saved with low-word first, then high-word. Each word saved with its low-byte first.
<P><DT><CODE>ARRAY</CODE>
<DD>
Array of BYTE values. Length depends on the description.
</DL>

<P>
The tables for the single modules state the type, name and
description of the data saved
in the modules. The data is saved in the order it is in the
tables, so no offset is given.

</P>


<H4><A NAME="SEC111" HREF="vice_toc.html#TOC111">8.2.2.2  Module framework</A></H4>



<H4><A NAME="SEC112" HREF="vice_toc.html#TOC112">8.2.2.3  CPU module</A></H4>



<H4><A NAME="SEC113" HREF="vice_toc.html#TOC113">8.2.2.4  CIA module</A></H4>

<P>
The CIA 6526 is an I/O port chip with 2 8-bit I/O ports, a shift register,
two timers, a Time of Day clock and interrupts.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Data direction register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Data direction register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TAC</TD>
<TD>Timer A counter value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TBC</TD>
<TD>Timer B counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_TEN</TD>
<TD>Time of Day - current tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_SEC</TD>
<TD>Time of Day - current seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_MIN</TD>
<TD>Time of Day - current minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TOD_HR</TD>
<TD>Time of Day - current hours</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SDR</TD>
<TD>contents of shift register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IER</TD>
<TD>mask of enabled interrupt masks</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRA</TD>
<TD>Control register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CRB</TD>
<TD>Control register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TAL</TD>
<TD>Timer A latch value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>TBL</TD>
<TD>Timer B latch value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IFR</TD>
<TD>mask of currently active interrupts</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PBSTATE</TD>
<TD>Bit 6/7 reflect the PB6/7 toggle bit state. Bit 2/3 reflect the corresponding port bit state.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SRHBITS</TD>
<TD>number of half-bits to still shift in/out SDR</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_TEN</TD>
<TD>Time of Day - alarm tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_SEC</TD>
<TD>Time of Day - alarm seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_MIN</TD>
<TD>Time of Day - alarm minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ALARM_HR</TD>
<TD>Time of Day - alarm hours</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>READICR</TD>
<TD>current clock minus the clock when ICR was read last plus 128.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODLATCHED</TD>
<TD>Bit 0: 1= latched for reading, Bit 1: 2=stopped for writing</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_TEN</TD>
<TD>Time of Day - latched tenth of second</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_SEC</TD>
<TD>Time of Day - latched seconds</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_MIN</TD>
<TD>Time of Day - latched minutes</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TODL_HR</TD>
<TD>Time of Day - latched hours</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>TOD_TICKS</TD>
<TD>clk ticks till next tenth of second</TD>
</TR></TABLE>



<H4><A NAME="SEC114" HREF="vice_toc.html#TOC114">8.2.2.5  VIA module</A></H4>

<P>
The VIA 6522 is the predecessor of the CIA and also an I/O port chip
with 2 8-bit I/O ports, a shift register,
two timers and interrupts.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Data direction register A</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Data direction register B</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T1L</TD>
<TD>Timer 1 Latch value</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T1C</TD>
<TD>Timer 1 counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>T2L</TD>
<TD>Timer 2 latch (8 bit as only lower byte is used)</TD>
</TR>
<TR><TD>WORD</TD>

<TD>T2C</TD>
<TD>Timer 2 counter value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>RUNFL</TD>
<TD>bit 7: timer 1 will generate IRQ on underflow; bit 6: timer 2 will generate IRQ on underflow</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SR</TD>
<TD>Shift register value</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>ACR</TD>
<TD>Auxiliary control register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PCR</TD>
<TD>Peripheral control register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IFR</TD>
<TD>active interrupts</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>IER</TD>
<TD>interrupt mask</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PB7</TD>
<TD>bit 7 = pb7 state</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SRHBITS</TD>
<TD>number of half-bits to shift out on SR</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CABSTATE</TD>
<TD>bit 7: state of CA2 pin, bit 6: state of CB2 pin</TD>
</TR></TABLE>



<H4><A NAME="SEC115" HREF="vice_toc.html#TOC115">8.2.2.6  PIA module</A></H4>

<P>
The PIA 6520 is a chip with two I/O ports (Parallel Interface Adapter)
and four additional handshake lines. The chip is pretty the same for
Port A and B, only that Port A implements handshake on read operation
and port B on write operation.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>ORA</TD>
<TD>Output register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>DDRA</TD>
<TD>Data Direction Register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CTRLA</TD>
<TD>Control Register A</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>ORB</TD>
<TD>Output register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>DDRB</TD>
<TD>Data Direction Register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CTRLB</TD>
<TD>Control Register B</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CABSTATE</TD>
<TD>Bit 7 = state of CA2, Bit 6 = state of CB2</TD>
</TR></TABLE>



<H4><A NAME="SEC116" HREF="vice_toc.html#TOC116">8.2.2.7  TPI module</A></H4>

<P>
The TPI 6525 is a chip with three I/O ports (Tri-Port-Interface). One of
the ports can double as an interrupt prioritizer. Therefore we also have
to save the states of the interrupt stack etc.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRA</TD>
<TD>Port A output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRB</TD>
<TD>Port B output register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>PRC</TD>
<TD>Port C output register (doubles as IRQ latch register)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRA</TD>
<TD>Port A data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRB</TD>
<TD>Port B data direction register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>DDRC</TD>
<TD>Port C data direction register (doubles as IRQ mask register)</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CR</TD>
<TD>Control Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>AIR</TD>
<TD>Active interrupt register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>STACK</TD>
<TD>Interrupt stack - the interrupt bits that are not (yet) served.</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CABSTATE</TD>
<TD>State of CA/CB pins. Bit 7 = state of CA, Bit 6 = state of CB</TD>
</TR></TABLE>



<H4><A NAME="SEC117" HREF="vice_toc.html#TOC117">8.2.2.8  SID module</A></H4>



<H4><A NAME="SEC118" HREF="vice_toc.html#TOC118">8.2.2.9  ACIA module</A></H4>

<P>
The ACIA 6551 is an RS232 interface chip. VICE emulates RS232 connections
via <CODE>/dev/ttyS*</CODE> (Unix) or <CODE>COM:</CODE> (DOS/WIN - not yet?).
When saving a snapshot, those connections are of course lost.
The state of the ACIA however is restored if possible. I.e. if a connection
is already open when restoring the snapshot, this connection is used
instead. If no connection is open, a carrier/DTR drop is emulated.

</P>
<P>
Version numbers: Major 1, Minor 0.

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>TDR</TD>
<TD>Transmit Data Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>RDR</TD>
<TD>Receiver Data Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>SR</TD>
<TD>Status Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CMD</TD>
<TD>Command Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CTRL</TD>
<TD>Ctrl Register</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>INTX</TD>
<TD>0 = no data to tx; 1 = Data is being transmitted; 2 = Data is being transmitted while data in TDR waiting to be put to internal transmit register</TD>
</TR>
<TR><TD>DWORD</TD>

<TD>TICKS</TD>
<TD>Clock ticks till the next TDR empty interrupt</TD>
</TR></TABLE>



<H4><A NAME="SEC119" HREF="vice_toc.html#TOC119">8.2.2.10  VIC-I module</A></H4>



<H4><A NAME="SEC120" HREF="vice_toc.html#TOC120">8.2.2.11  VIC-II module</A></H4>



<H4><A NAME="SEC121" HREF="vice_toc.html#TOC121">8.2.2.12  CRTC module</A></H4>



<H4><A NAME="SEC122" HREF="vice_toc.html#TOC122">8.2.2.13  C64 memory module</A></H4>



<H4><A NAME="SEC123" HREF="vice_toc.html#TOC123">8.2.2.14  C128 memory module</A></H4>



<H4><A NAME="SEC124" HREF="vice_toc.html#TOC124">8.2.2.15  VIC20 memory module</A></H4>

<P>
The size of the VIC20 memory module differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded.

</P>
<P>
Version numbers: Major 1, Minor 0

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>BYTE</TD>

<TD>CONFIG</TD>
<TD>Configuration register. Bits 0,1,2,3,5 reflect if the corresponding memory block is RAM (bit=1) or not (bit=0).</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM0</TD>
<TD>1k RAM dump $0000-$03ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM1</TD>
<TD>4k RAM dump $1000-$1fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>COLORRAM</TD>
<TD>2k Color RAM, $9400-$9bff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK0</TD>
<TD>if CONFIG &#38; 1 then: 3k RAM dump $0400-$0fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK1</TD>
<TD>if CONFIG &#38; 2 then: 8k RAM dump $2000-$3fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK2</TD>
<TD>if CONFIG &#38; 4 then: 8k RAM dump $4000-$5fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK3</TD>
<TD>if CONFIG &#38; 8 then: 8k RAM dump $6000-$7fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>BLK5</TD>
<TD>if CONFIG &#38; 32 then: 8k RAM dump $a000-$bfff</TD>
</TR></TABLE>



<H4><A NAME="SEC125" HREF="vice_toc.html#TOC125">8.2.2.16  PET memory module</A></H4>



<H4><A NAME="SEC126" HREF="vice_toc.html#TOC126">8.2.2.17  C610 memory module</A></H4>

<P>
The size of the C610 memory module differs with each different memory
configuration. The RAM configuration is saved in the snapshot, and
restored when the snapshot is loaded.

</P>
<P>
Version numbers: Major 1, Minor 0

</P>
<TABLE BORDER>

<TR><TD>Type</TD>

<TD>Name</TD>
<TD>Description</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>MEMSIZE</TD>
<TD>Memory size in 128k blocks (1=128k, 2=256k, 4=512k, 8=1024k)</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>CONFIG</TD>
<TD>Bit 0 = $f0800-$f0fff RAM, Bit 1 = $f1000-$f1fff RAM, Bit 2 = $f2000-$f3fff RAM, Bit 3 = $f4000-$f5fff RAM, Bit 4 = $f6000-$f7fff RAM, Bit 5 = $fc000-$fcfff RAM</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>HWCONFIG</TD>
<TD>Bit 0: 0 = CRTC, 1 = VIC-II video chip</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>EXECBANK</TD>
<TD>CPUs execution bank register</TD>
</TR>
<TR><TD>UBYTE</TD>

<TD>INDBANK</TD>
<TD>CPUs indirection bank register</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>SYSRAM</TD>
<TD>2k system RAM $f0000-$f07ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>VIDEO</TD>
<TD>2k video RAM $fd000-$fd7ff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM</TD>
<TD>RAM dump, size according to MEMSIZE</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM08</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 1 : 2k RAM $f0800-$f0fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM1</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 2 : 4k RAM $f1000-$f1fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM2</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 4 : 8k RAM $f2000-$f3fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM4</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 8 : 8k RAM $f4000-$f5fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAM6</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 16 : 8k RAM $f6000-$f7fff</TD>
</TR>
<TR><TD>ARRAY</TD>

<TD>RAMC</TD>
<TD>if memsize &#60; 1M and CONFIG &#38; 32 : 4k RAM $fc000-$fcfff</TD>
</TR></TABLE>

<P>
The RAM* arrays are only saved if the RAM itself is less than 1M.
If the memory size is 1M then those areas are taken from the
bank 15 area of the normal RAM.

</P>

<P><HR><P>
Go to the <A HREF="vice_1.html">first</A>, <A HREF="vice_7.html">previous</A>, <A HREF="vice_9.html">next</A>, <A HREF="vice_15.html">last</A> section, <A HREF="vice_toc.html">table of contents</A>.
</BODY>
</HTML>
