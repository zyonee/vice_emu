/* -*- C -*-
 *
 * via1drive1.def - Definitions for the VIA1 emulation in the 1541 disk drive.
 *
 * Written by
 *  Andre' Fachat (fachat@physik.tu-chemnitz.de)
 *  Daniel Sladic (sladic@eecg.toronto.edu)
 *  Andreas Boose (boose@unixserv.rz.fh-hannover.de)
 *  Ettore Perazzoli (ettore@comm2000.it)
 *
 * This file is part of VICE, the Versatile Commodore Emulator.
 * See README for copyright notice.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 *
 */


#define mycpu drive1

#define myclk drive_clk[1]

#define myrmwf drive1_rmw_flag

#define myvia via1d1

#define MYVIA VIA1D1


INCLUDES()
{
    #include "drive.h"
    #include "drivecpu.h"
    #include "iecdrive.h"
    #include "viad.h"
}

#define	GLOBALS

#define	via_set_int		drive1_set_irq
#define	VIA1D1_INT		IK_IRQ


/* #define VIA1D1_TIMER_DEBUG */

PRE_VIA_FUNCS()
{

void via1d1_set_atn(BYTE state)
{
#ifdef OLDIRQ
   if (state) {
      via1d1ifr |= 2;
   } else {
      via1d1ifr &= 0xfe;
   }
#else
   via1d1_signal(VIA_SIG_CA1, state ? VIA_SIG_RISE : 0);
#endif
}

static iec_info_t *iec_info;

}

#define	UNDUMP_PRA	/* FIXME!!! */

STORE_PRA()
{
    {
        if (drive[1].type == DRIVE_TYPE_1571) {
            if ((oldpa ^ byte) & 0x20)
                drive_set_1571_sync_factor(byte & 0x20, 1);
            if ((oldpa ^ byte) & 0x04)
                drive_set_1571_side((byte >> 2) & 1, 1);
        }
        if (drive_parallel_cable_enabled && drive[1].type == DRIVE_TYPE_1541)
            parallel_cable_drive_write(byte,
                                        (((addr == VIA_PRA)
                                        && ((via1d1[VIA_PCR] & 0xe) == 0xa))
                                        ? 1 : 0));
    }
}

#define	UNDUMP_PRB	/* FIXME!!! */

STORE_PRB()
{
    if (byte != oldpb) {
	if (iec_info != NULL) {
	    iec_info->drive2_data = ~byte;
	    iec_info->drive2_bus = (((iec_info->drive2_data << 3) & 0x40)
	        | ((iec_info->drive2_data << 6)
	        & ((~iec_info->drive2_data ^ iec_info->cpu_bus) << 3) & 0x80));
	    iec_info->cpu_port = iec_info->cpu_bus & iec_info->drive2_bus
	        & iec_info->drive_bus;
	    iec_info->drive2_port = iec_info->drive_port = (((iec_info->cpu_port >> 4) & 0x4)
	        | (iec_info->cpu_port >> 7)
	        | ((iec_info->cpu_bus << 3) & 0x80));
	} else {
	    iec_drive_write(~byte);
	}
    }
}

#define	STORE_PCR
#define	STORE_ACR
#define	STORE_SR
#define	STORE_T2L

RESET_VIA()
{
    iec_info = iec_get_drive_port();
}

READ_PRA()
{
    if (drive[1].type == DRIVE_TYPE_1571) {
        BYTE tmp;
        tmp = (drive_byte_ready(1) ? 0 : 0x80)
            | (drive[1].current_half_track == 2 ? 0 : 1);
        return (tmp & ~via1d1[VIA_DDRA])
            | (via1d1[VIA_PRA] & via1d1[VIA_DDRA]);
    }
    /*return*/
    byte = (drive_parallel_cable_enabled
            ? parallel_cable_drive_read((((addr == VIA_PRA) &&
                                          (via1d1[VIA_PCR] & 0xe) == 0xa))
                                        ? 1 : 0)
	    : 0xff );
/*
            : ((via1d1[VIA_PRA] & via1d1[VIA_DDRA])
               | (0xff & ~via1d1[VIA_DDRA])));
*/
}

READ_PRB()
{
    if (iec_info != NULL)
	byte = ((/*(via1d1[VIA_PRB] & 0x1a) |*/ iec_info->drive2_port) ^ 0x85) | 0x20;
    else
	byte = ((/*(via1d1[VIA_PRB] & 0x1a) |*/ iec_drive_read()) ^ 0x85) | 0x20;
}

#define POST_VIA_FUNCS


